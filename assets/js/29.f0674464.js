(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{317:function(a,s,v){"use strict";v.r(s);var r=v(14),t=Object(r.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("img",{attrs:{src:"/images/jvm/classLoader.png"}}),a._v(" "),s("h2",{attrs:{id:"类加载器的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类加载器的作用"}},[a._v("#")]),a._v(" 类加载器的作用")]),a._v(" "),s("p",[a._v("类加载器子系统负责从文件系统或者网络中加载class 文件，class文件中文件开头有特定的文件标识。")]),a._v(" "),s("p",[a._v("ClassLoader只负责class文件的加载，至于是否可以运行，则由execution engine 决定。")]),a._v(" "),s("p",[a._v("加载的类信息存放在一块称为方法区的内存空间，除类类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串和数字常量（这部分常量信息是class文件中常量池部分的内存映射）。")]),a._v(" "),s("img",{attrs:{src:"/images/jvm/classLoader1.png"}}),a._v(" "),s("ol",[s("li",[a._v("class file 存在于本地硬盘上，可以理解为设计师在纸上的模版，而最终这个模版在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一摸一样的实例。")]),a._v(" "),s("li",[a._v("class file加载到jvm中，被称为DNA元数据模版，放在方法区。")]),a._v(" "),s("li",[a._v("在.class文件->JVM->最终成为元数据模板，此过程就需要一个运输工具（类加载器 ClassLoader），扮演一个快递员的角色。")])]),a._v(" "),s("h2",{attrs:{id:"加载器分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加载器分类"}},[a._v("#")]),a._v(" 加载器分类")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("引导类加载器/启动类加载器（Bootstrap ClassLoader) --虚拟机自带")]),a._v(" "),s("blockquote",[s("p",[a._v("用C/C++实现，嵌套在JVM内部")]),a._v(" "),s("p",[a._v("用来加载java核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar、sun.boot.class.path路径下的内容）,用于提供JVM自身需要的类")]),a._v(" "),s("p",[a._v("并不继承自java.lang.ClassLoader，没有父类加载器（java代码获取此加载器是null）")]),a._v(" "),s("p",[a._v("加载扩展类和应用程序类加载器，并指定为他们的父类加载器")]),a._v(" "),s("p",[a._v("处于安全考虑，只加载包名为java、javax、sun等开头的类")])])]),a._v(" "),s("li",[s("p",[a._v("自定义类加载器（User-Defined ClassLoader）")]),a._v(" "),s("p",[a._v("① 扩展类加载器（Extension ClassLoader)--虚拟机自带")]),a._v(" "),s("blockquote",[s("p",[a._v("java语言编写，由sun.misc.Launcher$ExtClassLoader实现")]),a._v(" "),s("p",[a._v("派生于ClassLoader类")]),a._v(" "),s("p",[a._v("父类加载器为Bootstrap ClassLoader")]),a._v(" "),s("p",[a._v("从java.ext.dirs系统属性所制定的目录中加载类库，或者从JDK的安装目录jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载")])]),a._v(" "),s("p",[a._v("②  应用程序类加载器（AppClassLoader/System ClassLoader）--虚拟机自带")]),a._v(" "),s("blockquote",[s("p",[a._v("java语言编写，由sun.misc.Launcher$AppClassLoader实现")]),a._v(" "),s("p",[a._v("派生于ClassLoader类")]),a._v(" "),s("p",[a._v("父类加载器为Extension ClassLoader")]),a._v(" "),s("p",[a._v("负责加载环境变量classpath或系统属性java.class.path指定路径下的类库")]),a._v(" "),s("p",[a._v("该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载")])]),a._v(" "),s("p",[a._v("③ 用户自定义加载器")]),a._v(" "),s("blockquote",[s("p",[a._v("继承抽象类java.lang.ClassLoader类，实现自己的类加载器，满足特殊要求")])])])]),a._v(" "),s("h2",{attrs:{id:"双亲委派机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[a._v("#")]),a._v(" 双亲委派机制")]),a._v(" "),s("img",{attrs:{src:"/images/jvm/classLoader2.png"}}),a._v(" "),s("p",[a._v("如果自定义了个包名也是lang.java的String类，再在程序里面new String的时候还是调用的jdk自带的String（rt.jar包中java\\lang\\String.class），因为双亲委派机制，先向上不断委托到顶，找不到才会再往下交给子加载器。这个String在向上委托的时候， Bootstrap ClassLoader能加载到，所以返回的是引导类加载器加载的系统String。")]),a._v(" "),s("p",[s("font",{attrs:{color:"red"}},[a._v("避免类的重复加载；保护程序安全，防止核心API被随意篡改")])],1),a._v(" "),s("p",[s("font",{attrs:{color:"red"}},[a._v("在JVM中表示两个Class对象是同一个类两个必要条件：类的完整类名包括包名一致；加载这个类的ClassLoader（指ClassLoader实例对象）必须相同")])],1)])}),[],!1,null,null,null);s.default=t.exports}}]);