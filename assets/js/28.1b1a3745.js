(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{319:function(a,t,n){"use strict";n.r(t);var v=n(14),e=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"执行引擎概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎概述"}},[a._v("#")]),a._v(" 执行引擎概述")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("   +---------------------+\n   |                     |\n   |   JVM Execution     |\n   |     Engine          |\n   |                     |\n   +---------------------+\n              |\n              |              +-------------------+\n              +------------\x3e |  Interpreter      |\n              |              +-------------------+\n              |              |\n              |              |\n              |              |   +-------------------+\n              |              +-> |  Just-In-Time     |\n              |                 |  (JIT) Compiler   |\n              |                 +-------------------+\n              |                 |\n              |                 |\n              |                 |   +-------------------+\n              |                 +-> |  Garbage Collector|\n              |                    +-------------------+\n              |\n              |\n              |   +-------------------+\n              +-> |  Native Interface |\n                  +-------------------+\n")])])]),t("p",[a._v("JVM（Java虚拟机）执行引擎是JVM的一个关键组件，负责执行Java字节码指令。它是将Java程序从源代码编译为可执行代码并运行的核心部分。")]),a._v(" "),t("p",[a._v("JVM执行引擎主要有两个主要的组成部分：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("解释器（Interpreter）：解释器负责逐条解释和执行Java字节码指令。它将字节码翻译成机器码，并在运行时逐条执行这些指令。解释器的优势是可以直接执行字节码，适用于较小的方法或冷启动时，但由于逐条解释执行的特性，执行速度相对较慢。")])]),a._v(" "),t("li",[t("p",[a._v("即时编译器（Just-In-Time Compiler，JIT）：即时编译器将热点代码（被频繁执行的代码）动态地编译为本地机器码，以提高执行速度。JIT编译器会对方法进行分析，识别热点代码，并将其编译成高效的本地机器码。这样，热点代码在后续的执行中可以直接执行本地机器码，从而获得更高的执行性能。")])])]),a._v(" "),t("p",[a._v("JVM执行引擎在运行Java程序时起到关键作用。它通过解释器和即时编译器的组合，实现了Java程序的执行。解释器适用于快速启动和较小的方法，而即时编译器则提供了更高的执行效率，特别适用于热点代码的执行。JVM执行引擎的设计和优化对于Java程序的性能和执行效率至关重要。")]),a._v(" "),t("h3",{attrs:{id:"执行引擎的工作过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎的工作过程"}},[a._v("#")]),a._v(" 执行引擎的工作过程")]),a._v(" "),t("ol",[t("li",[a._v("执行引擎中执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器")]),a._v(" "),t("li",[a._v("每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址")]),a._v(" "),t("li",[a._v("当然方法中执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储中java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("java是半编译半解释型语言\n")])])]),t("h2",{attrs:{id:"解释器、jit编译器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释器、jit编译器"}},[a._v("#")]),a._v(" 解释器、JIT编译器")]),a._v(" "),t("ul",[t("li",[a._v("解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容翻译为对应平台的本地机器指令执行。当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。")]),a._v(" "),t("li",[a._v("HotSpot VM是目前市面上高性能虚拟机的代表作之一，采用解释器和即时编译器并存的架构。在虚拟机运行时，解释器和即时编译器能相互协作，各自取长补短，尽力去选择合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间：当虚拟机启动的时候，解释器可以首先发挥作用，不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高等的执行效率。")])]),a._v(" "),t("h3",{attrs:{id:"热点代码及探测方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#热点代码及探测方式"}},[a._v("#")]),a._v(" 热点代码及探测方式")]),a._v(" "),t("p",[a._v("是否需要启动JIT编译器将字节码直接编译为对应平台的机器指令，则需要根据代码被调用"),t("strong",[a._v("执行的频率")]),a._v("而定，关于那些需要被编译为本地代码的字节码，也被称为“"),t("strong",[a._v("热点代码")]),a._v("”。")]),a._v(" "),t("p",[a._v("目前HotSpot VM采用的热点探测方式是基于计数器的热点探测。会给每一个方法建立2个不同类型的计数器，分别为方法调用计数器和回边计数器。方法计数器用于统计方法的调用次数，回边计数器用于统计循环体执行的循环次数。但是并不是统计的绝对次数，而是相对的执行频率，即一段时间之内方法被调用的次数，"),t("strong",[a._v("超过一段时间限度")]),a._v("，还不满足交给JIT编译器，则调用计数器被减少一半，这个过程称为方法调用计数器热度的"),t("strong",[a._v("衰减")]),a._v("，这段时间被称为此方法统计的"),t("strong",[a._v("半衰周期")]),a._v("。")])])}),[],!1,null,null,null);t.default=e.exports}}]);