(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{312:function(a,t,v){"use strict";v.r(t);var _=v(14),r=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"一、垃圾回收概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、垃圾回收概述"}},[a._v("#")]),a._v(" 一、垃圾回收概述")]),a._v(" "),t("h3",{attrs:{id:"什么是垃圾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾"}},[a._v("#")]),a._v(" 什么是垃圾？")]),a._v(" "),t("p",[a._v("垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。")]),a._v(" "),t("h3",{attrs:{id:"为什么需要gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要gc"}},[a._v("#")]),a._v(" 为什么需要GC")]),a._v(" "),t("ul",[t("li",[a._v("如果不进行垃圾回收，内存迟早都会被消耗完。")]),a._v(" "),t("li",[a._v("垃圾回收可以清除内存里的记录碎片，碎片整理将所占用的堆内存移到堆的一端，便于JVM整理出的内存分配给新的对象。")]),a._v(" "),t("li",[a._v("应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。")])]),a._v(" "),t("h3",{attrs:{id:"java的垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java的垃圾回收机制"}},[a._v("#")]),a._v(" java的垃圾回收机制")]),a._v(" "),t("ul",[t("li",[a._v("自动内存管理，降低内存泄漏和内存溢出的风险。")]),a._v(" "),t("li",[a._v("程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发。")]),a._v(" "),t("li",[a._v("垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。其中，java堆是垃圾收集器的工作重点。从次数上讲：频繁收集Yong区，j较少收集old区，基本不动元空间。")])]),a._v(" "),t("p",[a._v("担忧：")]),a._v(" "),t("ul",[t("li",[a._v("弱化java开发人员在程序出现内存溢出时定位问题和解决问题的能力")]),a._v(" "),t("li",[a._v("了解JVM的自动内存分配和内存回收原理就非常重要，只有正真了解JVM是如何管理内存后，才能够在遇见OutOfMemoryError时，快速根据错误异常日志定位问题和解决问题")]),a._v(" "),t("li",[a._v("当垃圾收集称为系统达到更高并发量的瓶颈时，必须对这些自动化的技术实施必要的监控和调节。")])]),a._v(" "),t("h2",{attrs:{id:"二、垃圾回收的相关算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、垃圾回收的相关算法"}},[a._v("#")]),a._v(" 二、垃圾回收的相关算法")]),a._v(" "),t("h3",{attrs:{id:"_2-1-垃圾标记阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-垃圾标记阶段"}},[a._v("#")]),a._v(" 2.1 垃圾标记阶段")]),a._v(" "),t("p",[a._v("在GC执行垃圾回收之前，需要区分出内存中哪些对象是存活对象，哪些是已经死亡的对象。当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为死亡。判断对象存活一般有两种方式"),t("font",{attrs:{color:"red"}},[t("strong",[a._v("引用计数算法")])]),a._v("和"),t("font",{attrs:{color:"red"}},[t("strong",[a._v("可达性分析算法")])]),a._v("。")],1),a._v(" "),t("h4",{attrs:{id:"引用计数算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[a._v("#")]),a._v(" 引用计数算法")]),a._v(" "),t("p",[a._v("堆每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效，减1，如果引用计数器的值为0，则表示对象A可以回收。\n优点：实现简单，垃圾对象便于辨别；判定效率高，回收没有延迟性。\n缺点：")]),a._v(" "),t("ul",[t("li",[a._v("需要单独的字段存储计数器，增加了存储空间的开销")]),a._v(" "),t("li",[a._v("每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销")]),a._v(" "),t("li",[t("strong",[a._v("无法处理循环引用的情况，致命缺陷.")]),t("font",{attrs:{color:"red"}},[t("strong",[a._v("因此java没有使用")])])],1)]),a._v(" "),t("p",[a._v("Python使用的这个算法，如何解决循环引用？")]),a._v(" "),t("ul",[t("li",[a._v("手动解决：就是在合适的时机，解除引用关系。")]),a._v(" "),t("li",[a._v("使用弱引用weakref")])]),a._v(" "),t("h4",{attrs:{id:"可达性分析算法-或者根搜索算法、追踪性垃圾收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法-或者根搜索算法、追踪性垃圾收集"}},[a._v("#")]),a._v(" 可达性分析算法（或者根搜索算法、追踪性垃圾收集）")]),a._v(" "),t("p",[a._v("可以有效解决引用计算算法中循环引用的问题，防止内存泄漏的发生。（java使用）")]),a._v(" "),t("img",{attrs:{src:"/images/jvm/GC1.png"}})])}),[],!1,null,null,null);t.default=r.exports}}]);